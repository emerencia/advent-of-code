Difficulty Rank (from easy to difficult):

- 02: cube conundrum: fewest cubes possible to make the game possible. max.
- 01: trebuchet: string parsing/replacing. int to digit or reverse.
- 09: mirage maintenance: extrapolation. insert at the start and end of a vector.
- 15: lens library: input parsing, modulo, ascii, vectors of vectors. very easy.
- 06: wait for it: quadratic formula to determine number of ways to beat a record.
- 04: scratchcards: simple dynamic programming (get multiple of next cards)
- 11: cosmic expansion: double a grid in size. calculate pairwise manhattan distances.
- 07: camel cards: calculate the score of a hand in a card game. custom sort. lots of rules programming.
- 13: point of incidence: reflection lines in a grid. didn't have to optimize at all so pretty easy.
- 03: gear ratios: grid, adjacency, sets, maps, vectors of vectors.
- 16: the floor will be lava: queue with seen state. part b wasn't harder.
- 12: hot springs: recursive with memoization.
- 14: parabolic reflector dish: keeping a complicated state. modulo.
- 19: aplenty: have a set of ranges put through a set of rules and combine the results.
- 05: seed-to-soil map: queueing and splitting half-overlapping ranges or going in reverse.
- 10: pipe maze: scanline with some extra difficulties. hard if you don't know scanline.
- 08: haunted wasteland: lcm, chinese remainder theorem. impossible if you don't know it, easy if you do.
- 17: clumsy crucible: bfs with a queue and restricted state + restricted paths and optimization. part b was 2 minutes of work.
- 18: lavaduct lagoon: scanline with segments instead of cells.
